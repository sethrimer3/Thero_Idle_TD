<!DOCTYPE html>
<html>
<head>
    <title>Grapheme Sprite Test</title>
    <style>
        body { background: #1a1a1a; color: #fff; font-family: sans-serif; padding: 20px; }
        canvas { border: 2px solid #d4af37; margin: 20px 0; display: block; }
        .info { margin: 20px 0; }
    </style>
</head>
<body>
    <h1>Grapheme Sprite Rendering Test</h1>
    <p class="info">Testing the fix for grapheme sprite rendering. The canvas should show gold-tinted graphemes without turning the screen white.</p>
    <canvas id="testCanvas" width="400" height="300"></canvas>
    <p class="info" id="status">Loading sprite sheet...</p>
    
    <script type="module">
        const canvas = document.getElementById('testCanvas');
        const ctx = canvas.getContext('2d');
        const status = document.getElementById('status');
        
        // Sprite sheet config
        const SHIN_SCRIPT_SPRITE = {
            cellWidth: 200,
            cellHeight: 190,
            scale: 0.14,
            tint: '#d4af37',
        };
        
        // Load sprite sheet
        const spriteImage = new Image();
        spriteImage.onload = () => {
            status.textContent = 'Sprite loaded! Rendering graphemes...';
            renderTest();
        };
        spriteImage.onerror = () => {
            status.textContent = 'Error: Failed to load sprite sheet';
        };
        spriteImage.src = './assets/sprites/spires/shinSpire/Script.svg';
        
        function renderGraphemeSprite(ctx, frame, centerX, centerY) {
            const drawWidth = SHIN_SCRIPT_SPRITE.cellWidth * SHIN_SCRIPT_SPRITE.scale;
            const drawHeight = SHIN_SCRIPT_SPRITE.cellHeight * SHIN_SCRIPT_SPRITE.scale;
            const drawX = centerX - (drawWidth / 2);
            const drawY = centerY - (drawHeight / 2);
            const sourceX = frame.col * SHIN_SCRIPT_SPRITE.cellWidth;
            const sourceY = frame.row * SHIN_SCRIPT_SPRITE.cellHeight;

            // Use an offscreen canvas to apply the tint without affecting the main canvas
            const offscreen = document.createElement('canvas');
            offscreen.width = drawWidth;
            offscreen.height = drawHeight;
            const offCtx = offscreen.getContext('2d');
            
            offCtx.imageSmoothingEnabled = true;
            offCtx.drawImage(
                spriteImage,
                sourceX,
                sourceY,
                SHIN_SCRIPT_SPRITE.cellWidth,
                SHIN_SCRIPT_SPRITE.cellHeight,
                0,
                0,
                drawWidth,
                drawHeight
            );
            offCtx.globalCompositeOperation = 'source-in';
            offCtx.fillStyle = SHIN_SCRIPT_SPRITE.tint;
            offCtx.fillRect(0, 0, drawWidth, drawHeight);
            
            // Draw the tinted result onto the main canvas
            ctx.save();
            ctx.imageSmoothingEnabled = true;
            ctx.drawImage(offscreen, drawX, drawY);
            ctx.restore();
        }
        
        function renderTest() {
            // Clear canvas with dark background
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw some decorative elements
            ctx.fillStyle = '#333';
            ctx.fillRect(10, 10, canvas.width - 20, canvas.height - 20);
            
            // Render graphemes (letters A-E)
            const graphemes = [
                { row: 0, col: 0, x: 80, y: 75, label: 'A' },
                { row: 0, col: 1, x: 160, y: 75, label: 'B' },
                { row: 0, col: 2, x: 240, y: 75, label: 'C' },
                { row: 0, col: 3, x: 320, y: 75, label: 'D' },
                { row: 0, col: 4, x: 200, y: 150, label: 'E' },
            ];
            
            graphemes.forEach(g => {
                // Draw a circle background
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                ctx.arc(g.x, g.y, 18, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = '#d4af37';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Render grapheme sprite
                renderGraphemeSprite(ctx, { row: g.row, col: g.col }, g.x, g.y);
                
                // Label
                ctx.fillStyle = '#d4af37';
                ctx.font = '12px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(g.label, g.x, g.y + 35);
            });
            
            // Add text
            ctx.fillStyle = '#fff';
            ctx.font = '14px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('✓ Graphemes render correctly with gold tint', canvas.width / 2, canvas.height - 30);
            ctx.fillText('✓ Canvas background remains visible', canvas.width / 2, canvas.height - 10);
            
            status.textContent = '✓ Test passed! Graphemes rendered without white screen issue.';
            status.style.color = '#4CAF50';
        }
    </script>
</body>
</html>
